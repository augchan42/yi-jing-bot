// Require the necessary discord.js classes
const { Client, Collection, Events, GatewayIntentBits } = require("discord.js");
const dotenv = require("dotenv");
const fs = require("node:fs");
const path = require("node:path");
// Create a new client instance
const client = new Client({ intents: [GatewayIntentBits.Guilds] });
client.commands = new Collection();

const commandsPath = path.join(__dirname, "commands");
const commandFiles = fs
  .readdirSync(commandsPath)
  .filter((file) => file.endsWith(".js"));

for (const file of commandFiles) {
  const filePath = path.join(commandsPath, file);
  const command = require(filePath);
  // Set a new item in the Collection with the key as the command name and the value as the exported module
  if ("data" in command && "execute" in command) {
    client.commands.set(command.data.name, command);
  } else {
    console.log(
      `[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`
    );
  }
}
dotenv.config();
// When the client is ready, run this code (only once)
// We use 'c' for the event parameter to keep it separate from the already defined 'client'
client.once(Events.ClientReady, (c) => {
  console.log(`Ready! Logged in as ${c.user.tag}`);
});

// Log in to Discord with your client's token
client.login(process.env.TOKEN);

const hexagrams = require("./hexagrams");

// * Configures options to pass for CLI
function returnThings() {
  return generateHexagram();
}

const toss = () => {
  // * traditional calculations to generate i-ching from coin flips assign 'heads' the value of 3 and 'tails' the value of two.
  return Math.floor(Math.random() * 2) === 0 ? 3 : 2;
};
const generateLine = () => {
  // * Each line's value is the sum of the values generated by the toss of three coins
  return toss() + toss() + toss();
};

const generateHexagram = () => {
  // * Each hexagram is composed of 6 lines
  let hexagram = "";
  for (let i = 0; i < 6; i++) {
    hexagram += generateLine();
  }
  convertHexagrams(hexagram);
};

const convertHexagrams = (hexagram) => {
  // * Lines with a value of 6 or 9 are considered "changing" and as a result, a second hexagram is generated
  let changing = false;
  let primary = "";
  let relating = "";
  for (let i = 0; i < hexagram.length; i++) {
    if (hexagram[i] === "6") {
      changing = true;
      primary += 8;
      relating += 7;
    } else if (hexagram[i] === "9") {
      changing = true;
      primary += 7;
      relating += 8;
    } else {
      primary += hexagram[i];
      relating += hexagram[i];
    }
  }
  if (changing) {
    logFormat(primary, "Primary");
    logFormat(relating, "Relating");
  } else {
    logFormat(primary, "Primary");
  }
};

const locateHexagram = (hex) => {
  hex = Number(hex);
  const found = hexagrams.find((e) => {
    return e.pattern === hex;
  });
  return found;
};

const logFormat = (type, label) => {
  const result = locateHexagram(type);
  console.log(`
  ${label}
  ${result.symbol}
  ${(result.name.en, result.name.zh)}
  ${result.image}
  ${"Judgement:"}
  ${result.judgment}
   `);
};
